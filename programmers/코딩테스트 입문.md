## 1일차 ( 24.03.25 )
- 사칙연산

## 2일차 ( 24.03.25 )
- 사칙연산 2

## 3일차 ( 24.03.26 )
- 사칙연산 3, 배열

## 4일차 ( 24.03.26 )
- 사칙연산 4 , 배열

## 5일차 ( 24.03.27 )
- 문자열 수정 연습 1

## 6일차 ( 24.03.27 )
- 문자열 수정 연습 2

## 7일차 ( 24.03.28 )
- 수학 , 숫자 계산

## 8일차 ( 24.03.28 )
- `ord()` -> char to int
- `chr()` -> int to char

## 9일차 ( 24.03.29 )
- 수학 , 숫자 계산 2

## 10일차 ( 24.03.29 )
- 2차원 배열 , 조합

## 11일차 ( 24.03.30 )
- 2차원 배열 2 , 소수 구하기

## 12일차 ( 24.03.30 )
- 소인수분해 , 문자열 정렬

## 13일차 ( 24.03.31 )
- 문자열

## 14일차 ( 24.03.31 )
- `swapcase` -> 대소문자를 변경

## 15일차 ( 24.04.01 )
- ord 와 str 사용

## 16일차 ( 24.04.01 )
- set 의 집합
```python
arr1 = set([1,2,3])
arr2 = set([3,4,5])

arr1 & arr2 # [3]
arr1 | arr2 # [1,2,3,4,5]
```

## 17일차 ( 24.04.02 )
- 문자열

## 18일차 ( 24.04.02 )
- 정렬

## 19일차 ( 24.04.03 )
- 배열에 저장

## 20일차 ( 24.04.03 )
- 슬슬 실제 문제처럼 혼합해서 나오기 시작

## 21일차 ( 24.04.04 )
- [안전지대](https://school.programmers.co.kr/learn/courses/30/lessons/120866)
```python
def solution(board):
    N = len(board)
    dx = [-1, 1, 0, 0, -1, -1, 1, 1] # 8방향 탐색
    dy = [0, 0, -1, 1, -1, 1, -1, 1]
    
    # 지뢰 설치
    boom = []
    for i in range(len(board)):
        for j in range(len(board)):
            if board[i][j] == 1:
                boom.append((i,j)) # 지뢰일때의 인덱스 append
                
    # 지뢰가 설치된 곳 주변에 폭탄 설치
    for x, y in boom:
        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0 <= nx < N and 0 <= ny < N:
                board[nx][ny] = 1

    # 폭탄이 설치되지 않은 곳만 카운팅
    count = 0
    for x in range(N):
        for y in range(N):
            if board[x][y] == 0:
                count += 1
    return count
```

## 22일차 ( 24.04.05 )
- 숫자 배열을 만들때 , 
`[for i in lines]` 처럼 만들 수 있음

## 23일차 ( 24.04.06 ~ 24.04.07 )
- 이차원 배열에서도 max 사용 가능
- 논리적으로는 정답이지만 , 더 간편하게 사용할 수 있는 방법이 있음 ( lamda 등 )

## 24일차 ( 24.04.08 )
- 이진수 , 8진수 , 16진수
```python
bin(number) -> 2진수 
oct(number) -> 8진수
hex(number) -> 16진수
```
